const express = require('express');
const { ObjectId } = require('mongodb');
const { connectToDb, getDb } = require('./db');

const PORT = 3000;

const app = express();
/* 13. Однако ньюанс заключается в том, что мы не можем просто так напрямую вытянуть все данные из поля запроса. Чтобы получить доступ к информации, хранящейся
 в body нам нужен дополнительный middleware из экспресс. Поэтому сразу под созданием приложения с помощью метода use определяем middleware - express.json()
 И таким способом мы получаем возможность читать данные из запроса. */
app.use(express.json())

let db;

connectToDb((err) => {
    if (!err) {
        app.listen(PORT, (err) => {
            err ? console.log(err) : console.log(`Listen port ${PORT}`);
        });
        db = getDb();
    } else {
        console.log(`DB connection error: ${err}`);
    }
})


/* 11. Поскольку код немного разросся, чтобы сохранить его читаемость, в отдельную функцию мы можем поместить возврат ошибок. Поскольку логика везде одинаковая,
это ответ со статусом 500 и сообщение об ошибке, ее можно инкапсулировать в отдельной функции. Которую назовем handleError. В свою очередь аргументами она 
будет принимать объект ответа и ошибку в виде типа string. Теперь все блоки catch можно немного сократить. Используя функцию handleError, в вызов которой 
отправляем объект res и сообщение c ошибкой, вызов этой функции отправляем в тело колбэка метода catch. */
const handleError = (res, error) => {
    res.status(500).json({ error })
}

// Нужно создать роут, по которому мы будем запрашивать данные из MongoDB
/* 1. Обращаемся к созданному экспресс приложению, вызываем у него метод get, который принимает два аргумента, первый - это путь по которому
запрашиваются данные. Второй аргумент, это колбэк, который принимает объекты запроса и ответа. Внутри данного роута, который в теле 
колбэка мы можем обратиться к нашей базе. При успешном подключении, она хранится в переменной db */
app.get('/movies', (req, res) => {
    /* 4. Настало время обработать данные и вернуть их. Для этого создаем пустой массив movies. Далее после метода find добавляем метод forEach, внутри 
    которого мы перебираем полученный объект курсор с помощью переданного колбэка, создаем колбэк, туда передаем параметр, который будет каждым итерируемым 
    элементом курсора. Из этого объекта мы получаем документ и далее этот документ добавляем в созданный массив movies. */
    const movies = [];
    /* 2. Внутри данного роута, который в теле колбэка мы можем обратиться к нашей базе. При успешном подключении, она хранится в переменной db */
    db
        .collection('movies') // 3. Внутрь метода передаем имя коллекции, которая есть в базе данных.
        .find() /* 4. таким образом мы хотим получить все документы, хранящиеся в нашей коллекции. На самом деле find не возвращает документы, он возвращает указатель
    на возвращенную коллекцию документов, которая называется курсором. Курсоры инкапсулируют в себе наборы, получаемые из БД объектов. По умолчанию курсор
    будет повторяться автоматически при возврате результата запроса, но можно также явно просматривать элементы, возвращаемые в курсоре один за другим. Таким 
    образом, основной ньанс мы не получаем коллекцию, а получаем специальный объект курсор. Курсор обладает набором методов. Например hasNext, который 
    показывает при переборе имеется ли еще в наборе документ. Метод next извлекает текущий документ и перемещает курсор к следующему документу в наборе.
    Также для перебора документов в курсоре в качестве альтернативы можно использовать конструкцию итератора JS forEach, важная особенность заключается также 
    в том, что монгоДБ при find-запросе не возвращает все данные.  */
        /* 7. Кстати нашу цепочку методов мы можем расширить и после find() указать например метод sort() внутрь которого передать объект с ключом title и 
        значением 1, т.о. возвращаемые фильмы мы отсортируем по заголовку в алфавитном порядке. Нажимаем SEND и теперь фильмы возвращаются по алфавиту. Кстати
        протестировать наш работающий API мы можем не только в Postman, но и в браузере: копируем путь запроса и вставляем в адресную строку хром. Результатом 
        получаем тот же JSON со списком фильмов.  */
        .sort({ title: 1 })
        .forEach((movie) => {
            movies.push(movie)
        })
        /* 5. И поскольку данные методы являются асинхронными, то в конце мы добавляем блок then, внутри которого модифицируем возвращаем возвращаемый ответ,
        для начала - для успешного ответа устанавливаем статус 200, а затем с помощью метода json возвращаем созданный массив movies. Теперь созданную логику
        нам нужно протестировать в постмане/инсомнии. Создаем гет-запрос, затем в поле запроса вводим http://localhost:3000/movies, /movies - это роут, по 
        которому мы запрашиваем все фильмы. И нажимаем SEND, и если все верно, мы должны получить полный список фильмов, которые хранятся в бд по указанной 
        коллекции. Мы создали первый эндпоинт для нашего API */
        .then(() => {
            res
                .status(200)
                .json(movies)
        })
        /* 6. Давайте расширим его негативным кейсом, это будет блок catch, то есть если вдруг запрос к БД упадет и мы ничего не получим, то в ответе вернутся
        статус 500 и в методе json передадим объект с строкой ошибки.  */
        // .catch(() => {
        //     res
        //         .status(500)
        //         .json({ error: "Something goes wrong..." })
        // })
        .catch(() => handleError(res, "Something goes wrong..."));
})


/* Теперь рассмотрим получение элемента по id, а также его удаление, рассмотрим как получить один фильм по его id */
app.get('/movies/:id', (req, res) => {
    /*8. Создаем роут для получения элемента по id, он также начинается на /movies, а также имеет динамическую составляющую, о том, что id не статическое 
    значение говорит двоеточие в самом начале его определения. Как и в прошлый раз нам нужна коллекция movies. Поскольку мы ищем один фильм, вместо find()
    используем findOne, внутрь которого передаем объект с полем _id, а его значение будем вытягивать из req.params.id, то есть получать значение id, которое
    введено в адресную строку браузера. Здесь важный момент в том, что id нужно обернуть в специальную функцию ObjectId, которая идет из MongoDB. Далее
    описываем блок then. В случае успешного запроса мы возвращаем ответ со статусом 200, а также документ, который возвращаем из БД, его мы передаем в 
    параметр колбэка, который назовем doc, этот колбэк передается в вызов метода then, блок catch полностью дублирует предыдущий.     */
    /* 9. Логику роута нужно обернуть в условие if-else. Для if определяем условие, что получаемый из запроса ID должен быть валидным. ObjectId содержит 
    специальный метод isValid, который и осуществляет подобную проверку - внутрь мы передаем req.params.id. И только в этом случае, когда Id верный, мы 
    осуществляем запрос. В блоке else мы вернем ответ со статусом 500 и ошибкой, что id не верный. */

    if (ObjectId.isValid(req.params.id)) {
        db
            .collection('movies')
            .findOne({ _id: new ObjectId(req.params.id) })
            .then((doc) => {
                res
                    .status(200)
                    .json(doc)
            })
            // .catch(() => {
            //     res
            //         .status(500)
            //         .json({ error: "Something goes wrong..." })
            // })
            .catch(() => handleError(res, "Something goes wrong..."));
    } else {
        // res
        //     .status(500)
        //     .json({ error: "Wrong id" })
        handleError(res, "Something goes wrong...")
    }

})

/* 10. Следующую операцию с данными, которую мы рассмотрим, это удаление документа. Для данной логики нам понадобится новый роут. Применяем метод delete, путь
остается тем же - он же route, проверка на валидность id и обращение к коллекции сохраняется. Нам нужно только заменить findOne на deleteOne, которая 
используется для удаления одного элемента. В then нам будет возвращаться не документ, а инфа о результате удаления. Ее же мы и отправим пользователю.
 */

app.delete('/movies/:id', (req, res) => {
    if (ObjectId.isValid(req.params.id)) {
        db
            .collection('movies')
            .deleteOne({ _id: new ObjectId(req.params.id) })
            .then((result) => {
                res
                    .status(200)
                    .json(result);
            })
            // .catch(() => {
            //     res
            //         .status(500)
            //         .json({ error: "Something goes wrong..." })
            // })
            .catch(() => handleError(res, "Something goes wrong..."))
    } else {
        // res
        //     .status(500)
        //     .json({ error: '' })
        handleError(res, "Something goes wrong...")
    }
})

/* 12. Рассмотрим две оставшиеся операции из стэка CRUD операций, это добавление нового элемента в базу и редактирование. Начнем с создания отдельного роута.
Опять же обращаемся к созданному приложению app. И вызываем у него специальный метод post. В качестве пути используем стандартный путь /movies. И точно также
передаем колбэк вторым аргументом. А в сам колбэк пробрасываем объекты запроса и ответа. Основная идея в том, что для того чтобы добавить новый документ в 
БД, информацию этого элемента нужно как-то передать через запрос. В качестве такого временного хранилища информации мы воспользуемся телом запроса, которое
будет содержать все необходимые данные. Для этого воспользуемся объектом req и его свойством body. */
/*14. Возвращаемся обратно к созданному роуту и наполним его логикой. */
app.post('/movies/', (req, res) => {
    db
        .collection('movies')
        .insertOne(req.body)
        .then((result) => {
            console.log(req.body);
            res
                .status(201)
                .json(result)
        })
        .catch(() => handleError(res, "Something goes wrong"))
})

app.patch('/movies/:id', (req, res) => {
    if (ObjectId.isValid(req.params.id)) {
        db
            .collection('movies')
            .updateOne({ _id: new ObjectId(req.params.id) }, { $set: req.body })
            .then((result) => {
                res
                    .status(200)
                    .json(result);
            })
            // .catch(() => {
            //     res
            //         .status(500)
            //         .json({ error: "Something goes wrong..." })
            // })
            .catch(() => handleError(res, "Something goes wrong..."))
    } else {
        // res
        //     .status(500)
        //     .json({ error: '' })
        handleError(res, "Something goes wrong...")
    }
})









app.get('/movies/countDocuments', (req, res) => {
    db
        .collection('movies')
        .find()
        .count()
        .then((count) => {
            res
                .status(200)
                .json(count)
        })
        .catch(() => {
            res
                .status(500)
                .json({ error: "Something goes wrong..." })
        })
})